---
title: "DATA643 Project 3 - Matrix Factorization Methods"
author: "Yun Mai, Kelly Shaffer "
date: "June 23, 2017"
output: github_document
---

In this project, matrix factorization will be used for performing collaborative filtering to predict missing values of ranking matrix. SVD Approximation will be used to do laten semantic indexing.  The process would be decomposeing the original ranking matrix based on Singular Value Decomposition and  keeping only first r most significance entities.


```{r setup, include=FALSE,evl=F}
knitr::opts_chunk$set(echo = TRUE)
```


```{r,eval=F}
install.packages("recommenderlab")
install.packages("recosystem")
install.packages("NMFN")
install.packages("Metrics")

library(devtools)
install.packages("quanteda") 
install_github(repo = "SVDApproximation", username = "tarashnot")
```


```{r}
suppressWarnings(suppressMessages(library(Matrix)))
suppressWarnings(suppressMessages(library(recommenderlab)))
suppressWarnings(suppressMessages(library(irlba)))
suppressWarnings(suppressMessages(library(recosystem)))
suppressWarnings(suppressMessages(library(dplyr)))
suppressWarnings(suppressMessages(library(tidyr)))
suppressWarnings(suppressMessages(library(knitr)))

#linear algebra  here used for rmse calculation
suppressWarnings(suppressMessages(library(Metrics)))

suppressWarnings(suppressMessages(library(SlopeOne)))
suppressWarnings(suppressMessages(library(SVDApproximation)))
suppressWarnings(suppressMessages(library(NMFN)))

suppressWarnings(suppressMessages(library(data.table)))
suppressWarnings(suppressMessages(library(RColorBrewer)))

suppressWarnings(suppressMessages(library(ggplot2)))
```
#### 1. Data

```{r}
data(MovieLense)
kable(head(MovieLense,n=5))
```

**View the raw data**
```{r}
# convert ratings data to realRatingMatrix for implement of recommenderlab package
MovieLense_copy <- MovieLense 
ml <- as(MovieLense_copy,"realRatingMatrix")
image(sample(ml, 500), main = "Raw ratings")
rm(MovieLense_copy )
gc() #release memory
```

**Statistics of ratings data:**

```{r}
# add numeric movie_ID to the data
movie <- data.frame('movieID'=1, 'movie'=MovieLense[,2])
movie <- as.data.frame(table(MovieLense[,2]))
movie$movieID <- seq(1:nrow(movie))
movie <- movie[,c(3,1:2)]
colnames(movie)<- c('movieID','title','Freq')
rating <- merge(MovieLense, movie, by.x = "item_id",by.y = "title")
rating <- rating[,c(2,4,3)]
rating[,c(1,3)] <- lapply(rating[,c(1,3)],function(x) as.integer(x))

#convert to data.table
as.data.table(rating)
gc() #release memory

# visualize_ratings(ratings_table = rating) visualize_ratings function from SVDApproximation package did not work for rating but worked well for the package build-in data,ratings. So I will view the data by using ggplot2 as shown in following.
```

```{r}
# use visualize_ratings function from SVDApproximation to visualize statistics for all ratings: item count of different ratings,item histogram of users' average ratings, item histogram of items' average ratings, item histogram of number of rated items by user, item histogram of number of scores items have

#distribution of ratings
rating_frq <- as.data.frame(table(rating$rating))
#distribution of rating mean of users
user_mean <- rating %>% 
  group_by(user_id) %>% 
  summarise(mean=mean(rating),number=n())
#distribution of rating mean of users
item_mean <- rating %>% 
  group_by(movieID) %>% 
  summarise(mean=mean(rating),number=n())

ggplot(rating_frq,aes(Var1,Freq)) +   
  geom_bar(aes(fill = Var1), position = "dodge", stat="identity",fill="palegreen",xlab="Score")
par(mfrow=c(2,2))
ggplot(user_mean,aes(mean)) +
  geom_histogram(binwidth = 0.05,col='white',fill="plum") + labs(x = "User Average Score")
ggplot(item_mean,aes(mean)) +
  geom_histogram(binwidth = 0.05,col='white',fill="sandybrown") + labs(x = "Item Average Score")
ggplot(user_mean,aes(number)) +
  geom_histogram(binwidth = 0.08,fill="plum") + labs(x = "Number of Rated Items")
ggplot(item_mean,aes(number)) +
  geom_histogram(binwidth = 0.08,fill="sandybrown") + labs(x = "Number of Scores Item has")
gc() #release memory

```

** Normolization**

Nornalized will be used for irlab package where the SVD function does not split the data into train and test data sets.
```{r}
# calculate glabal mean based on train data set
global_mean <- mean(rating$rating)

# normalize the train and test data by subtracting glabal mean
rating_nor<- rating
rating_nor$rating <- rating$rating - global_mean
gc() #release memory
```

#### **Matrix Factorization by Singular Value Decomposition**

#### 1. Build Recommendation Model Base On SVD Method
```{r}
# view the available registried mathods in recommenderlab
recommenderRegistry$get_entries()
gc() #release memory
```


From the list, we can see SVD (Recommender based on SVD approximation with column-mean imputation) and SVDF (Recommender based on Funk SVD with gradient descend) are available from recommenderlab package.


**1.1 SVD Modeling**

**1.1.1 Prepare Data**
```{r}
# Convert the data to wide dataframe
rating_c <- as.data.frame(rating_nor)
rating_w <- spread(rating_c,movieID,rating)
rm(rating_c)

# get half of the data because of small RAM 
set.seed(124)
sample1 <- sample.int(n = nrow(rating_w), size = floor(.5*nrow(rating_w)), replace = F)
sample2 <- sample.int(n = ncol(rating_w), size = floor(.5*ncol(rating_w)), replace = F)
rating_2 <- rating_w[sample1,sample2]#
rating_3 <- cbind('user_id'=as.numeric(rownames(rating_2)),rating_2)
rating_2 <- rating_3 # raing_2 is the wide table or user-item matrix in a dataframe format

#convert data back to long table
rating_1 <- gather(rating_3,'movieID','rating',2:833)
rating_1$movieID <- as.numeric(rating_1$movieID) # raing_1 is the long table in a dataframe format
rm(rating_3)
gc() #release memory

# split the data into train set and test set
# set Seed to make sure the reproducibility of the sampling results
set.seed(125)
sample3 <- sample.int(n = nrow(rating_2), size = floor(.8*nrow(rating_2)), replace = F)
train_2 <- rating_2[sample3,] # train_1 is the wide table in a dataframe format
test_2 <- rating_2[-sample3,] # test_1 is the wide table in a dataframe format
#convert data back to long table
train_1 <- gather(train_2,'movieID','rating',2:833) # train_2 is the long table in a dataframe format
train_1$movieID<-as.numeric(train_1$movieID)
test_1 <- gather(test_2,'movieID','rating',2:833) # test_2 is the long table in a dataframe format
test_1$movieID<-as.numeric(test_1$movieID)
gc() #release memory

# find out which user and movie have been allocated into train and test set respectively
user_all <- as.list(unique(rating_2$user_id))
movie_all <- as.list(unique(rating_1$movieID))
user_train <- user_all[sample3]
movie_train <- movie_all[sample3]
user_test <- user_all[-sample3]
movie_test <- movie_all[-sample3]
gc() #release memory

# convert the data to realRatingMatrix format
rating_4 <- as.matrix(rating_2[,-1])
rating_m <- as(rating_4,"realRatingMatrix") # rating_m is the realRatingMatrix format for all data
movie_m <- getRatingMatrix(rating_m)
rm(rating_4)

train_3 <- as.matrix(train_2[,-1])
train_m <- as(train_3,"realRatingMatrix") # train_m is the realRatingMatrix format for train set
rm(train_3)

test_3 <- as.matrix(test_2[,-1])
test_m <- as(test_3,"realRatingMatrix") # train_m is the realRatingMatrix format for train set
rm(test_3)

evaluationScheme(rating_m, method="split", train=0.8, k=1, given=3)
gc() #release memory

evaluationScheme(train_m, method="split", train=0.8, k=1, given=3)
evaluationScheme(test_m, method="split", train=0.8, k=1, given=3)
gc() #release memory
```

**1.1.2 Get SVD**

```{r}
r <- Recommender(rating_m, method = "SVD")
names(getModel(r))
imt <- getModel(r)$svd
names(imt)
print(paste("the number of latent features (k) is ",getModel(r)$k))

r_train <- Recommender(train_m, method = "SVD")
imt_train <- getModel(r_train)$svd
print(paste("the number of latent features (k) for train set is ",getModel(r_train)$k))

r_test <- Recommender(test_m, method = "SVD")
imt_test <- getModel(r_test)$svd
print(paste("the number of latent features (k) for test setis ",getModel(r_test)$k))
gc() #release memory
```

**1.1.3 Making Predictions From the Decomposed Matrices**

Obtain SVD matrices from SVD model.By multiply U, ??, and $V^{T}$ back to get the rank k=10 approximation of original rating matrix.

```{r}
u_sigma <- imt$u %*% diag(imt$d)
predict_rating_2 <- u_sigma %*% t(imt$v) # predict_rating_2 is the user-item version for predtion rating for all data

u_sigma_train <- imt_train$u %*% diag(imt_train$d)
predict_train_2 <- u_sigma_train %*% t(imt_train$v) # predict_train_2 is the user-item version for predtion rating for train set

predict_test_2 <- predict(r_train, test_m, verbose = TRUE,type="ratingMatrix") # predict_test_2 is the user-item version for predtion rating for test set
gc() #release memory

#u_sigma_test <- imt_test$u %*% diag(imt_test$d)
#predict_test <- u_sigma_test %*% t(imt_test$v)

```

```{r}
# set the memory the process needs
memory.limit(size=40000)

# convert user-item matrix to long data frame
predict_rating <- as.data.frame(predict_rating_2)
predict_rating <- cbind('user_id'= unlist(user_all),predict_rating)
colnames(predict_rating)<- c('user_id',unlist(movie_all))
predict_all <- gather(predict_rating,movieID, rating,2:833)
predict_all$movieID <- as.numeric(predict_all$movieID)
rm(predict_rating)
gc() #release memory
kable(head(predict_all),caption = "All Prediction")

predict_train <- as.data.frame(predict_train_2)
predict_train <- cbind('user_id'= unlist(user_train),predict_train)
colnames(predict_train)<- c('user_id',unlist(movie_all))
predict_train_1 <- gather(predict_train,movieID, rating,2:833)
rm(predict_train)
gc() #release memory
kable(head(predict_train_1),caption = "Prediction For Test set")

predict_test <- as.data.frame(as.matrix(getRatingMatrix(predict_test_2)))
predict_test <- cbind('user_id'= unlist(user_test),predict_test)
colnames(predict_test)<- c('user_id',unlist(movie_all))
predict_test_1 <- gather(predict_test,movieID, rating,2:833)
rm(predict_test)
gc() #release memory
kable(head(predict_test_1),caption = "Prediction For Test set")

```

**1.1.4 Making Recommendations**

Based on the laten index, we know the predicted ratings to all movies for every user. The movie with the high predicted ratings that a user hasn't rated will be returned.

**Predition for all data**
```{r}
# find the moive user have not rated yet
predict_all[,c('movieID','rating')] <- lapply(predict_all[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- rating_1[!(is.na(rating_1$rating)),]
not_rated <- anti_join(predict_all, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6))

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict_all, old_rated, by = c("user_id","movieID"))

rmse_1 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for all rating is",round(rmse_1,2)))
```

**Predition for train set**
```{r}
# find the moive user have not rated yet
predict_train_1[,c('movieID','rating')] <- lapply(predict_train_1[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- train_1[!(is.na(train_1$rating)),]
not_rated <- anti_join(predict_train_1, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for train set")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict_train_1, old_rated, by = c("user_id","movieID"))

rmse_2 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for train set is",round(rmse_2,2)))
```

**Predition for test set**
```{r}
# find the moive user have not rated yet
predict_test_1[,c('movieID','rating')] <- lapply(predict_test_1[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- test_1[!(is.na(test_1$rating)),]
not_rated <- anti_join(predict_test_1, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for test set")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict_test_1, old_rated, by = c("user_id","movieID"))

rmse_3 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for test set is",round(rmse_3,2)))
```

#### 2. Build Recommendation Model Base On Funk SVD Method

**2.1 Prepare Data**
```{r}
# Convert the data to wide dataframe
rating_c <- as.data.frame(rating)
rating_w <- spread(rating_c,movieID,rating)
rm(rating_c)

# get half of the data because of small RAM 
set.seed(124)
sample1 <- sample.int(n = nrow(rating_w), size = floor(.5*nrow(rating_w)), replace = F)
sample2 <- sample.int(n = ncol(rating_w), size = floor(.5*ncol(rating_w)), replace = F)
rating_2 <- rating_w[sample1,sample2]#
rating_3 <- cbind('user_id'=as.numeric(rownames(rating_2)),rating_2)
rating_2 <- rating_3 # raing_2 is the wide table or user-item matrix in a dataframe format

#convert data back to long table
rating_1 <- gather(rating_3,'movieID','rating',2:833)
rating_1$movieID <- as.numeric(rating_1$movieID) # raing_1 is the long table in a dataframe format
rm(rating_3)
gc() #release memory

# split the data into train set and test set
# set Seed to make sure the reproducibility of the sampling results
set.seed(125)
sample3 <- sample.int(n = nrow(rating_2), size = floor(.8*nrow(rating_2)), replace = F)
train_2 <- rating_2[sample3,] # train_1 is the wide table in a dataframe format
test_2 <- rating_2[-sample3,] # test_1 is the wide table in a dataframe format
#convert data back to long table
train_1 <- gather(train_2,'movieID','rating',2:833) # train_2 is the long table in a dataframe format
train_1$movieID<-as.numeric(train_1$movieID)
test_1 <- gather(test_2,'movieID','rating',2:833) # test_2 is the long table in a dataframe format
test_1$movieID<-as.numeric(test_1$movieID)
gc() #release memory

# find out which user and movie have been allocated into train and test set respectively
user_all <- as.list(unique(rating_2$user_id))
movie_all <- as.list(unique(rating_1$movieID))
user_train <- user_all[sample3]
movie_train <- movie_all[sample3]
user_test <- user_all[-sample3]
movie_test <- movie_all[-sample3]
gc() #release memory

# convert the data to realRatingMatrix format
rating_4 <- as.matrix(rating_2[,-1])
rating_m <- as(rating_4,"realRatingMatrix") # rating_m is the realRatingMatrix format for all data
movie_m <- getRatingMatrix(rating_m)
rm(rating_4)

train_3 <- as.matrix(train_2[,-1])
train_m <- as(train_3,"realRatingMatrix") # train_m is the realRatingMatrix format for train set
rm(train_3)

test_3 <- as.matrix(test_2[,-1])
test_m <- as(test_3,"realRatingMatrix") # train_m is the realRatingMatrix format for train set
rm(test_3)

evaluationScheme(rating_m, method="split", train=0.8, k=1, given=3)
gc() #release memory

evaluationScheme(train_m, method="split", train=0.8, k=1, given=3)
evaluationScheme(test_m, method="split", train=0.8, k=1, given=3)
gc() #release memory
```

**2.2 Get SVD**

```{r}
r <- Recommender(rating_m, method = "SVDF")
names(getModel(r))
imt <- getModel(r)$svd
names(imt)
print(paste("the number of latent features (k) is ",getModel(r)$k))

r_train <- Recommender(train_m, method = "SVDF")
imt_train <- getModel(r_train)$svd
print(paste("the number of latent features (k) for train set is ",getModel(r_train)$k))

#r_test <- Recommender(test_m, method = "SVDF")
#imt_test <- getModel(r_test)$svd
#print(paste("the number of latent features (k) for test setis ",getModel(r_test)$k))
gc() #release memory
```

**2.3 Making Predictions From the Decomposed Matrices**

Obtain SVD matrices from SVD model.By multiply U, ??, and $V^{T}$ back to get the rank k=10 approximation of original rating matrix.

```{r}
predict_rating_2 <- imt$U %*% t(imt$V) # predict_rating_2 is the user-item version for predtion rating for all data

predict_train_2 <- imt_train$U %*% t(imt_train$V) # predict_train_2 is the user-item version for predtion rating for train set

predict_test_2 <- predict(r_train, test_m, verbose = TRUE,type="ratingMatrix") # predict_test_2 is the user-item version for predtion rating for test set
gc() #release memory
```

```{r}
# set the memory the process needs
memory.limit(size=40000)

# convert user-item matrix to long data frame
predict_rating <- as.data.frame(predict_rating_2)
predict_rating <- cbind('user_id'= unlist(user_all),predict_rating)
colnames(predict_rating)<- c('user_id',unlist(movie_all))
predict_all <- gather(predict_rating,movieID, rating,2:833)
predict_all$movieID <- as.numeric(predict_all$movieID)
rm(predict_rating)
gc() #release memory
kable(head(predict_all),caption = "All Prediction")

predict_train <- as.data.frame(predict_train_2)
predict_train <- cbind('user_id'= unlist(user_train),predict_train)
colnames(predict_train)<- c('user_id',unlist(movie_all))
predict_train_1 <- gather(predict_train,movieID, rating,2:833)
rm(predict_train)
gc() #release memory
kable(head(predict_train_1),caption = "Prediction For Test set")

predict_test <- as.data.frame(as.matrix(getRatingMatrix(predict_test_2)))
predict_test <- cbind('user_id'= unlist(user_test),predict_test)
colnames(predict_test)<- c('user_id',unlist(movie_all))
predict_test_1 <- gather(predict_test,movieID, rating,2:833)
rm(predict_test)
gc() #release memory
kable(head(predict_test_1),caption = "Prediction For Test set")

```

**2.4 Making Recommendations**

Based on the laten index, we know the predicted ratings to all movies for every user. The movie with the high predicted ratings that a user hasn't rated will be returned.

**Predition for all data**
```{r}
# find the moive user have not rated yet
predict_all[,c('movieID','rating')] <- lapply(predict_all[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- rating_1[!(is.na(rating_1$rating)),]
not_rated <- anti_join(predict_all, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6))

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict_all, old_rated, by = c("user_id","movieID"))

rmse_1 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for all rating is",round(rmse_1,2)))
```

**Predition for train set**
```{r}
# find the moive user have not rated yet
predict_train_1[,c('movieID','rating')] <- lapply(predict_train_1[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- train_1[!(is.na(train_1$rating)),]
not_rated <- anti_join(predict_train_1, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for train set")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict_train_1, old_rated, by = c("user_id","movieID"))

rmse_2 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for train set is",round(rmse_2,2)))
```

**Predition for test set**
```{r}
# find the moive user have not rated yet
predict_test_1[,c('movieID','rating')] <- lapply(predict_test_1[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- test_1[!(is.na(test_1$rating)),]
not_rated <- anti_join(predict_test_1, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for test set")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict_test_1, old_rated, by = c("user_id","movieID"))

rmse_3 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for test set is",round(rmse_3,2)))
```

**1. In terms of RMSE, SVD based matrix decomposition performed better when the model was built on the normalized ratings instead of buidt on the original rating(data not shown).**

**2. Funk SVD is not appropreiate as it generate none predction.**

#### 3.Optimize the number of latent features (r or k) by minimizing the Root Mean Square Error (using irlba package to try different r)**

```{r}
#The irlba function only computes the number of singular values corresponding to the maximum of the desired singular vectors, max(nu, nv).
# max(nu, nv) must be strictly less than min(nrow(dtm), ncol(dtm)), so first see the 
max_nunv <-min(nrow(movie_m), ncol(movie_m))
print(paste("Number of left singular vectors to estimate, nu, and number of right, nv, should be less than",max_nunv,"."))
# try several r to see which one give the best prediction
SVD_5=irlba(getRatingMatrix(rating_m),nu=5,nv=5)
SVD_10=irlba(getRatingMatrix(rating_m),nu=10,nv=10)
SVD_20=irlba(getRatingMatrix(rating_m),nu=20,nv=20)
SVD_50=irlba(getRatingMatrix(rating_m),nu=50,nv=50)
SVD_100=irlba(getRatingMatrix(rating_m),nu=100,nv=100)
plot(SVD_10$d, main="Largest singular values (r=10)")
```


```{r}
u_sigma <- SVD_10$u %*% diag(SVD_10$d)
predict_rating <- u_sigma %*% t(SVD_10$v)

# convert user-item matrix to long data frame
predict_rating <- as.data.frame(predict_rating)
predict_rating <- cbind('user_id'= unlist(user_all),predict_rating)
colnames(predict_rating)<- c('user_id',unlist(movie_all))
predict <- gather(predict_rating,movieID, rating,2:833)

# find the moive user have not rated yet
predict[,c('movieID','rating')] <- lapply(predict[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- rating_1[!(is.na(rating_1$rating)),]
not_rated <- anti_join(predict, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for all rating")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict, old_rated, by = c("user_id","movieID"))

rmse_4 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for all rating when r=10 is",round(rmse_4,2)))
```

**The RMSE derived from SVD_10 calculated by irlba pacakge is the different from that calclated by recommenderlab. irlba use truncated SVD**

Several number of singular values(5, 20, 50, and 100) will be compared with r=10. Similar computaions will be performed as above so the code will be hide but only the results will be shown to make it consice.

```{r}
u_sigma <- SVD_5$u %*% diag(SVD_5$d)
predict_rating <- u_sigma %*% t(SVD_5$v)

# convert user-item matrix to long data frame
predict_rating <- as.data.frame(predict_rating)
predict_rating <- cbind('user_id'= unlist(user_all),predict_rating)
colnames(predict_rating)<- c('user_id',unlist(movie_all))
predict <- gather(predict_rating,movieID, rating,2:833)

# find the moive user have not rated yet
predict[,c('movieID','rating')] <- lapply(predict[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- rating_1[!(is.na(rating_1$rating)),]
not_rated <- anti_join(predict, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for all rating")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict, old_rated, by = c("user_id","movieID"))

rmse_5 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for all rating when r=5 is",round(rmse_5,2)))
```

```{r}
u_sigma <- SVD_20$u %*% diag(SVD_20$d)
predict_rating <- u_sigma %*% t(SVD_20$v)

# convert user-item matrix to long data frame
predict_rating <- as.data.frame(predict_rating)
predict_rating <- cbind('user_id'= unlist(user_all),predict_rating)
colnames(predict_rating)<- c('user_id',unlist(movie_all))
predict <- gather(predict_rating,movieID, rating,2:833)

# find the moive user have not rated yet
predict[,c('movieID','rating')] <- lapply(predict[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- rating_1[!(is.na(rating_1$rating)),]
not_rated <- anti_join(predict, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for all rating")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict, old_rated, by = c("user_id","movieID"))

rmse_6 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for all rating when r=20 is",round(rmse_6,2)))
```

```{r}
u_sigma <- SVD_50$u %*% diag(SVD_50$d)
predict_rating <- u_sigma %*% t(SVD_50$v)

# convert user-item matrix to long data frame
predict_rating <- as.data.frame(predict_rating)
predict_rating <- cbind('user_id'= unlist(user_all),predict_rating)
colnames(predict_rating)<- c('user_id',unlist(movie_all))
predict <- gather(predict_rating,movieID, rating,2:833)

# find the moive user have not rated yet
predict[,c('movieID','rating')] <- lapply(predict[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- rating_1[!(is.na(rating_1$rating)),]
not_rated <- anti_join(predict, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for all rating")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict, old_rated, by = c("user_id","movieID"))

rmse_7 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for all rating when r=50 is",round(rmse_7,2)))
```

```{r}
u_sigma <- SVD_100$u %*% diag(SVD_100$d)
predict_rating <- u_sigma %*% t(SVD_100$v)

# convert user-item matrix to long data frame
predict_rating <- as.data.frame(predict_rating)
predict_rating <- cbind('user_id'= unlist(user_all),predict_rating)
colnames(predict_rating)<- c('user_id',unlist(movie_all))
predict <- gather(predict_rating,movieID, rating,2:833)

# find the moive user have not rated yet
predict[,c('movieID','rating')] <- lapply(predict[,c('movieID','rating')], function(x) as.numeric(x))
old_rated <- rating_1[!(is.na(rating_1$rating)),]
not_rated <- anti_join(predict, old_rated, by = c("user_id","movieID"))

# find the movie with high predicted ratings to recommend to users
rec_movie <- not_rated %>% 
  group_by(user_id) %>%
  arrange(desc(rating)) %>%
  filter(row_number() <= 5L) 
kable(head(rec_movie, n=6),caption = "Recommendation for all rating")

# use rmse function of Metrics to calculate RMSE for evaluation of accuracy of predictions
new_rating <- semi_join(predict, old_rated, by = c("user_id","movieID"))

rmse_8 <-rmse(old_rated$rating,new_rating$rating)
print(paste("RMSE of prediction for all rating when r=100 is",round(rmse_8,2)))
```

```{r}
kable(RMSE <- data.frame('r'=c(5,10,20,50,100),'RMSE'=c(rmse_5,rmse_4,rmse_6,rmse_7,rmse_8)))
ggplot(RMSE,aes(r,RMSE))+
  geom_line(col='blue')+geom_point(col='blue')+labs(x="Number of Singular Values",y="RMSE")
```

**The RMSE decreased as the number of singular values increase, suggesting that SVD approximation get closer to real rating as we increased the latent features.**




